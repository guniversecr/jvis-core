# ADR-002: Functional Stack Scaffolding

**Status:** Approved
**Date:** 2026-02-13
**Author:** Winston (Architect)
**Reviewers:** Dev, QA

---

## Context

JVIS currently generates application scaffolds that are **runnable but hollow**:
- Entry points work (`uvicorn src.main:app` starts)
- Health endpoints respond
- Config files are production-ready (Docker, Makefile, linting)
- Tests run and pass (smoke tests only)
- **But**: Domain models, repositories, services, and business logic layers are empty directories with `__init__.py` stubs

The ACTION-PLAN identifies this as critical gap #5: "Stacks generate empty scaffolds — no functional code." A user running `jvis new --stack python-fastapi` should get a working CRUD API demonstrating the stack's architectural patterns, not a skeleton they have to build from scratch.

## Decision

### Scope: Python FastAPI First (Reference Implementation)

Start with `python-fastapi` as the reference stack. Other stacks (react-vite, nodejs-express, etc.) follow in future epics using this as the pattern.

### What "Functional" Means

A generated project must:
1. **Start without errors** — `uvicorn src.main:app` works (already true)
2. **Have a working CRUD entity** — Item model with Create/Read/List/Update/Delete
3. **Use the stack's architecture patterns** — Clean Architecture (domain → use_cases → infrastructure → controllers)
4. **Have real tests that pass** — Unit tests for service, integration tests for API endpoints
5. **Have database integration** — SQLAlchemy async + Alembic migrations (conditional on database selection)
6. **Be immediately extensible** — Developer copies the Item pattern to add new entities

### Architecture Pattern (Python FastAPI)

```
src/
├── main.py                              # FastAPI app + lifespan + router registration
├── domain/
│   ├── entities/
│   │   ├── base.py                      # SQLAlchemy declarative base
│   │   └── item.py                      # Item model (reference entity)
│   └── schemas/
│       └── item.py                      # Pydantic request/response schemas
├── use_cases/
│   └── item_service.py                  # Business logic (CRUD operations)
├── infrastructure/
│   ├── config/
│   │   └── settings.py                  # Pydantic Settings (env vars)
│   ├── database.py                      # SQLAlchemy engine + session factory
│   └── repositories/
│       └── item_repository.py           # Database access layer
├── controllers/
│   └── api/
│       ├── health.py                    # Health endpoint (existing)
│       └── items.py                     # Item CRUD endpoints
tests/
├── conftest.py                          # Async DB fixtures + TestClient
├── test_health.py                       # Existing smoke tests
└── test_items.py                        # Item CRUD tests
alembic/
├── env.py                               # Alembic config with async support
└── versions/                            # Migration directory
```

### Design Principles

1. **SSOT** — Database URL in `.env` / `settings.py` only. Not hardcoded in templates.
2. **Database-conditional** — If `database_type == "none"`, skip SQLAlchemy/Alembic entirely. Use in-memory list for Item storage instead.
3. **Copy-paste pattern** — The Item entity is a reference. Developers copy `item.py`, `item_repository.py`, `item_service.py`, `items.py` to create new entities.
4. **No over-engineering** — Simple async CRUD. No JWT, no auth, no middleware beyond what's essential. Keep it learnable.
5. **Template variables only** — Use `{{ project_name }}`, `{{ project_description }}`, `{{ database_type }}`, `{{ date }}`. No new variables.

### What We're NOT Doing

- No authentication/authorization (that's a story-level decision for each project)
- No complex business logic (the Item entity is intentionally simple)
- No frontend in backend stacks
- No other stacks in this epic (react-vite, nodejs-express are future epics)

## Stories

| Story | Title | Scope |
|-------|-------|-------|
| 2.1 | Database + Config + Entity Layer | settings.py, database.py, base.py, item.py entity + schema |
| 2.2 | Repository + Service + Controller + Tests | CRUD operations, REST endpoints, working tests |

## Consequences

### Positive
- Users get a working CRUD API out of the box
- Demonstrates Clean Architecture patterns that agents understand
- Reduces "first 2 hours" of every new project
- Sets the pattern for making other stacks functional

### Negative
- Template complexity increases (more .j2 files to maintain)
- Tests need to cover more generated code
- Risk of generated code becoming outdated vs framework versions

### Risks
- SQLAlchemy version pinning may cause dependency conflicts
- Database-conditional templates add branching complexity
- Generated Alembic config needs to be correct across all DB types

---

*Generated by Winston - System Architect | JVIS Framework*
*Date: 2026-02-13*
