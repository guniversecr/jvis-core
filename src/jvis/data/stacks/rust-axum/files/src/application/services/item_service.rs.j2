use chrono::Utc;
use uuid::Uuid;

use crate::application::dto::{CreateItemDto, UpdateItemDto};
use crate::domain::entities::Item;
use crate::domain::errors::AppError;
use crate::infrastructure::database::DbPool;

pub struct ItemService;

impl ItemService {
    pub async fn create(pool: &DbPool, dto: CreateItemDto) -> Result<Item, AppError> {
        let id = Uuid::new_v4();
        let now = Utc::now();
{% if database_type in ("postgresql", "mysql") %}
        sqlx::query_as!(
            Item,
            r#"INSERT INTO items (id, name, description, created_at, updated_at)
               VALUES ($1, $2, $3, $4, $5)
               RETURNING id, name, description, created_at, updated_at"#,
            id,
            dto.name,
            dto.description.unwrap_or_default(),
            now,
            now,
        )
        .fetch_one(pool)
        .await
        .map_err(|e| AppError::Internal(e.to_string()))
{% else %}
        let _ = (pool, id, now);
        Ok(Item {
            id,
            name: dto.name,
            description: dto.description,
            created_at: now,
            updated_at: now,
        })
{% endif %}
    }

    pub async fn list(pool: &DbPool) -> Result<Vec<Item>, AppError> {
{% if database_type in ("postgresql", "mysql") %}
        sqlx::query_as!(Item, "SELECT id, name, description, created_at, updated_at FROM items ORDER BY created_at DESC")
            .fetch_all(pool)
            .await
            .map_err(|e| AppError::Internal(e.to_string()))
{% else %}
        let _ = pool;
        Ok(vec![])
{% endif %}
    }

    pub async fn get_by_id(pool: &DbPool, id: Uuid) -> Result<Item, AppError> {
{% if database_type in ("postgresql", "mysql") %}
        sqlx::query_as!(
            Item,
            "SELECT id, name, description, created_at, updated_at FROM items WHERE id = $1",
            id,
        )
        .fetch_optional(pool)
        .await
        .map_err(|e| AppError::Internal(e.to_string()))?
        .ok_or_else(|| AppError::NotFound(format!("Item {id} not found")))
{% else %}
        let _ = pool;
        Err(AppError::NotFound(format!("Item {id} not found")))
{% endif %}
    }

    pub async fn update(pool: &DbPool, id: Uuid, dto: UpdateItemDto) -> Result<Item, AppError> {
{% if database_type in ("postgresql", "mysql") %}
        let existing = Self::get_by_id(pool, id).await?;
        let name = dto.name.unwrap_or(existing.name);
        let description = dto.description.or(existing.description);
        let now = Utc::now();

        sqlx::query_as!(
            Item,
            r#"UPDATE items SET name = $1, description = $2, updated_at = $3 WHERE id = $4
               RETURNING id, name, description, created_at, updated_at"#,
            name,
            description,
            now,
            id,
        )
        .fetch_one(pool)
        .await
        .map_err(|e| AppError::Internal(e.to_string()))
{% else %}
        let _ = (pool, id, dto);
        Err(AppError::Internal("No database configured".to_string()))
{% endif %}
    }

    pub async fn delete(pool: &DbPool, id: Uuid) -> Result<(), AppError> {
{% if database_type in ("postgresql", "mysql") %}
        let result = sqlx::query!("DELETE FROM items WHERE id = $1", id)
            .execute(pool)
            .await
            .map_err(|e| AppError::Internal(e.to_string()))?;

        if result.rows_affected() == 0 {
            return Err(AppError::NotFound(format!("Item {id} not found")));
        }
        Ok(())
{% else %}
        let _ = (pool, id);
        Err(AppError::Internal("No database configured".to_string()))
{% endif %}
    }
}
